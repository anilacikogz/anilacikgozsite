<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3310</title>
    
    <link rel="icon" type="image/png" href="https://github.com/anilacikogz/anilacikgozsite/blob/main/sitelogo.png?raw=true">
    
    <style>
        /* CSS kodunda bir değişiklik yok, aynı kalabilir */
        html, body { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        #startMenu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 40px; background-color: rgba(0, 0, 0, 0.75); border-radius: 15px; text-align: center; color: white; display: flex; flex-direction: column; gap: 20px; border: 2px solid rgba(255, 255, 255, 0.2); box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #startMenu h1 { margin: 0; font-size: 36px; text-shadow: 0 0 10px #00aaff; }
        #playerNameInput { font-size: 18px; padding: 10px; border-radius: 8px; border: 2px solid #555; background-color: #333; color: white; text-align: center; }
        #startButton { font-size: 20px; padding: 12px 24px; border-radius: 8px; border: none; background: linear-gradient(145deg, #007BFF, #0056b3); color: white; cursor: pointer; font-weight: bold; transition: transform 0.2s ease, box-shadow 0.2s ease; }
        #startButton:hover { transform: scale(1.05); box-shadow: 0 0 15px #00aaff; }
    </style>
</head>
<body>
    <div id="startMenu">
        <h1>33 10</h1>
        <input type="text" id="playerNameInput" placeholder="Adınızı Girin" maxlength="15">
        <button id="startButton">Oyuna Başla</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- OYUN AYARLARI ---
        const worldWidth = 12000; // DEĞİŞTİ: Dünya daha da büyüdü
        const worldHeight = 12000;
        const foodCount = 1200;
        const botCount = 50;
        const playerResponsiveness = 0.04;
        const basePlayerSpeed = 8;
        const initialPlayerRadius = 25;
        const minRadiusToSplit = 35; // YENİ: Bölünmek için gereken minimum boyut
        const splitEjectSpeed = 30;  // YENİ: Bölünen parçanın fırlama hızı
        const mergeCooldown = 8000;  // YENİ: Parçaların birleşmeden önce beklemesi gereken süre (ms)

        const botNames = ["Gölge", "Fırtına", "Cevher", "Kasırga", "Vortex", "Pusat", "Baron", "Alfa", "Venom", "Raptor", "Spectre", "Kral", "Bora", "Şettin", "Cati", "Dat", "Yati"];

        // --- CANVAS VE ELEMENTLER ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startMenu = document.getElementById('startMenu');
        const playerNameInput = document.getElementById('playerNameInput');
        const startButton = document.getElementById('startButton');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

        // --- OYUN DEĞİŞKENLERİ ---
        let playerCells = [], foods = [], bots = [], score = 0; // DEĞİŞTİ: player -> playerCells
        let gameState = 'menu';
        let highScore = localStorage.getItem('ioGameHighScore') || 0;
        let mouse = { x: canvas.width / 2, y: canvas.height / 2 };
        let camera = { x: 0, y: 0 };
        
        // --- OLAY DİNLEYİCİLER ---
        canvas.addEventListener('mousemove', (event) => { mouse.x = event.clientX; mouse.y = event.clientY; });
        canvas.addEventListener('click', () => { if (gameState === 'gameOver') { showMenu(); }});
        
        // YENİ: Sağ tık ile bölünme
        canvas.addEventListener('contextmenu', (event) => {
            event.preventDefault(); // Tarayıcının sağ tık menüsünü engelle
            if (gameState === 'playing') {
                splitPlayerCells();
            }
        });

        startButton.addEventListener('click', () => {
            let playerName = playerNameInput.value.trim() || "Misafir";
            startMenu.style.display = 'none';
            startGame(playerName);
        });

        const getDistance = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
        const getRandomColor = () => `hsl(${Math.random() * 360}, 80%, 60%)`;

        // --- VARLIK OLUŞTURMA ---
        function createPlayer(name) {
            // DEĞİŞTİ: Oyuncuyu artık bir dizi (array) olarak başlatıyoruz
            playerCells = [{
                x: worldWidth / 2, y: worldHeight / 2,
                radius: initialPlayerRadius, color: 'hsl(200, 100%, 70%)', 
                isPlayer: true, name: name,
                vx: 0, vy: 0, // Hız vektörleri
                mergeTime: 0 // Birleşme zamanlayıcısı
            }];
        }
        
        // --- Diğer create fonksiyonları aynı ---
        function createFoods() { foods = Array.from({ length: foodCount }, () => ({ x: Math.random() * worldWidth, y: Math.random() * worldHeight, radius: 8, color: getRandomColor() })); }
        function createBot() { return { x: Math.random() * worldWidth, y: Math.random() * worldHeight, radius: Math.random() * 15 + 10, color: getRandomColor(), speed: Math.random() * 0.015 + 0.005, state: 'seekingFood', target: null, name: botNames[Math.floor(Math.random() * botNames.length)] }; }
        function createBots() { bots = Array.from({ length: botCount }, createBot); }

        // --- ÇİZİM FONKSİYONLARI ---
        function drawEntity(entity) { /* ... kod aynı ... */ }
        function drawName(entity) { /* ... kod aynı ... */ }
        function drawGrid() { /* ... kod aynı ... */ }
        function drawWorldBounds() { /* ... kod aynı ... */ }

        // --- GÜNCELLEME VE MANTIK ---
        function updatePlayer() {
            if (playerCells.length === 0) return;
            const targetX = mouse.x + camera.x;
            const targetY = mouse.y + camera.y;

            playerCells.forEach(cell => {
                // Hız ve boyut dinamiği
                const speedFactor = Math.sqrt(initialPlayerRadius / cell.radius);
                const maxPlayerSpeed = basePlayerSpeed * speedFactor;
                const distance = getDistance(cell.x, cell.y, targetX, targetY);

                if (distance > 1) {
                    let moveX = (targetX - cell.x) * playerResponsiveness;
                    let moveY = (targetY - cell.y) * playerResponsiveness;
                    const currentSpeed = getDistance(0, 0, moveX, moveY);
                    if (currentSpeed > maxPlayerSpeed) {
                        moveX = (moveX / currentSpeed) * maxPlayerSpeed;
                        moveY = (moveY / currentSpeed) * maxPlayerSpeed;
                    }
                    cell.x += moveX;
                    cell.y += moveY;
                }

                // Fırlama hızını uygula ve yavaşlat (sürtünme)
                cell.x += cell.vx;
                cell.y += cell.vy;
                cell.vx *= 0.92;
                cell.vy *= 0.92;

                // Sınırlar
                cell.x = Math.max(cell.radius, Math.min(worldWidth - cell.radius, cell.x));
                cell.y = Math.max(cell.radius, Math.min(worldHeight - cell.radius, cell.y));
            });
        }
        
        // YENİ: Oyuncu hücrelerini bölme fonksiyonu
        function splitPlayerCells() {
            const cellsToSplit = [...playerCells]; // Diziyi kopyala, döngü sırasında bozulmasın
            cellsToSplit.forEach(cell => {
                if (playerCells.length < 16 && cell.radius >= minRadiusToSplit) {
                    const originalMass = cell.radius * cell.radius;
                    const newMass = originalMass / 2;
                    cell.radius = Math.sqrt(newMass); // Eski hücreyi küçült
                    
                    const targetX = mouse.x + camera.x;
                    const targetY = mouse.y + camera.y;
                    const dist = getDistance(cell.x, cell.y, targetX, targetY) || 1;
                    const dirX = (targetX - cell.x) / dist;
                    const dirY = (targetY - cell.y) / dist;

                    const newCell = {
                        ...cell,
                        radius: cell.radius,
                        vx: dirX * splitEjectSpeed,
                        vy: dirY * splitEjectSpeed,
                        mergeTime: Date.now() + mergeCooldown // Bu hücre bir süre birleşemez
                    };
                    cell.mergeTime = Date.now() + mergeCooldown; // Ana hücre de birleşemez

                    playerCells.push(newCell);
                }
            });
        }
        
        // DEĞİŞTİ: Kamera artık parçaların merkezini takip ediyor
        function updateCamera() {
            if (playerCells.length === 0) return;
            let totalX = 0, totalY = 0;
            playerCells.forEach(cell => { totalX += cell.x; totalY += cell.y; });
            const centerX = totalX / playerCells.length;
            const centerY = totalY / playerCells.length;

            camera.x = centerX - canvas.width / 2;
            camera.y = centerY - canvas.height / 2;
            camera.x = Math.max(0, Math.min(worldWidth - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(worldHeight - canvas.height, camera.y));
        }

        function checkCollisions() {
            // DEĞİŞTİ: Artık playerCells dizisini ve botları birleştiriyoruz
            const allEntities = [...playerCells, ...bots].filter(e => e);
            
            // Yem yeme
            allEntities.forEach(entity => { /* ... kod aynı ... */ });

            // Varlıkların birbirini yemesi
            for (let i = 0; i < allEntities.length; i++) { /* ... kod aynı ... */ }
            
            // YENİ: Oyuncu parçalarının birleşmesi
            for (let i = 0; i < playerCells.length; i++) {
                for (let j = i + 1; j < playerCells.length; j++) {
                    const c1 = playerCells[i];
                    const c2 = playerCells[j];
                    const now = Date.now();
                    
                    if (getDistance(c1.x, c1.y, c2.x, c2.y) < c1.radius + c2.radius / 2 && now > c1.mergeTime && now > c2.mergeTime) {
                        const mass1 = c1.radius * c1.radius;
                        const mass2 = c2.radius * c2.radius;
                        c1.radius = Math.sqrt(mass1 + mass2); // c1 büyür
                        playerCells.splice(j, 1); // c2 silinir
                        j--; // Dizinin boyutu değiştiği için index'i ayarla
                    }
                }
            }
        }
        
        function updateBots() { /* ... kod aynı, hedef olarak artık playerCells[0]'ı alabilir... */ }

        // --- ANA OYUN DÖNGÜSÜ ---
        function gameLoop() {
            if (gameState === 'playing') {
                updatePlayer();
                updateBots();
                updateCamera();
                checkCollisions();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            drawGrid();
            drawWorldBounds();
            foods.forEach(drawEntity);
            bots.forEach(bot => { drawEntity(bot); drawName(bot); });
            // DEĞİŞTİ: Artık tüm oyuncu parçalarını çiziyoruz
            playerCells.forEach(cell => { drawEntity(cell); drawName(cell); });

            ctx.restore();

            // Skor tabloları...
            if (gameState !== 'menu') {
                score = Math.floor(playerCells.reduce((sum, cell) => sum + (cell.radius * cell.radius) - (initialPlayerRadius*initialPlayerRadius), 0) / 100);
                /* ... skor çizim kodu aynı ... */
            }

            if (gameState === 'gameOver') { /* ... kod aynı ... */ }
            
            requestAnimationFrame(gameLoop);
        }

        function startGame(playerName) {
            createPlayer(playerName);
            createFoods();
            createBots();
            score = 0;
            gameState = 'playing';
            updateCamera();
        }
        
        function showMenu() {
            gameState = 'menu';
            startMenu.style.display = 'flex';
        }

        gameLoop();
        
        // --- Kısaltılmış Fonksiyonlar (içerikleri aynı) ---
        function drawEntity(entity) { ctx.save(); ctx.beginPath(); ctx.arc(entity.x, entity.y, entity.radius, 0, Math.PI * 2); ctx.shadowColor = entity.color; ctx.shadowBlur = 15; ctx.fillStyle = entity.color; ctx.fill(); ctx.closePath(); ctx.restore(); }
        function drawName(entity) { ctx.fillStyle = "white"; ctx.font = `${Math.max(12, entity.radius / 3)}px sans-serif`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.lineWidth = 3; ctx.strokeStyle = "black"; ctx.strokeText(entity.name, entity.x, entity.y); ctx.fillText(entity.name, entity.x, entity.y); }
        function drawGrid() { ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 1; const gridSize = 100; const startX = Math.floor(camera.x / gridSize) * gridSize; const startY = Math.floor(camera.y / gridSize) * gridSize; for (let x = startX; x < camera.x + canvas.width + gridSize; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, startY + canvas.height + gridSize); ctx.stroke(); } for (let y = startY; y < camera.y + canvas.height + gridSize; y += gridSize) { ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(startX + canvas.width + gridSize, y); ctx.stroke(); } }
        function drawWorldBounds() { ctx.strokeStyle = '#ff5555'; ctx.lineWidth = 10; ctx.strokeRect(0, 0, worldWidth, worldHeight); }
        function updateBots() { const allThreatsAndPrey = [...playerCells, ...bots]; bots.forEach(bot => { let closestThreat = null, closestPrey = null, closestFood = null; let minDistThreat = 400, minDistPrey = 500, minDistFood = 600; allThreatsAndPrey.forEach(entity => { if (entity === bot || !entity) return; const dist = getDistance(bot.x, bot.y, entity.x, entity.y); if (entity.radius > bot.radius * 1.1 && dist < minDistThreat) { minDistThreat = dist; closestThreat = entity; } else if (bot.radius > entity.radius * 1.1 && dist < minDistPrey) { minDistPrey = dist; closestPrey = entity; } }); if (closestThreat) { bot.state = 'fleeing'; bot.target = closestThreat; } else if (closestPrey) { bot.state = 'hunting'; bot.target = closestPrey; } else { bot.state = 'seekingFood'; foods.forEach(food => { const dist = getDistance(bot.x, bot.y, food.x, food.y); if (dist < minDistFood) { minDistFood = dist; closestFood = food; } }); bot.target = closestFood; } if (bot.target) { let targetX = bot.target.x; let targetY = bot.target.y; if (bot.state === 'fleeing') { targetX = bot.x - (bot.target.x - bot.x); targetY = bot.y - (bot.target.y - bot.y); } bot.x += (targetX - bot.x) * bot.speed; bot.y += (targetY - bot.y) * bot.speed; } bot.x = Math.max(bot.radius, Math.min(worldWidth - bot.radius, bot.x)); bot.y = Math.max(bot.radius, Math.min(worldHeight - bot.radius, bot.y)); }); }
        function checkCollisions() { const allEntities = [...playerCells, ...bots].filter(e => e); allEntities.forEach(entity => { for (let i = foods.length - 1; i >= 0; i--) { const food = foods[i]; if (getDistance(entity.x, entity.y, food.x, food.y) < entity.radius) { entity.radius += 20 / entity.radius; foods.splice(i, 1); foods.push({ x: Math.random() * worldWidth, y: Math.random() * worldHeight, radius: 8, color: getRandomColor() }); } } }); for (let i = 0; i < allEntities.length; i++) { for (let j = i + 1; j < allEntities.length; j++) { const e1 = allEntities[i]; const e2 = allEntities[j]; if (!e1 || !e2 || (e1.isPlayer && e2.isPlayer)) continue; if (getDistance(e1.x, e1.y, e2.x, e2.y) < Math.max(e1.radius, e2.radius)) { const [bigger, smaller] = e1.radius > e2.radius ? [e1, e2] : [e2, e1]; if (bigger.radius > smaller.radius * 1.15) { bigger.radius = Math.sqrt(bigger.radius*bigger.radius + smaller.radius*smaller.radius); if (smaller.isPlayer) { const pIndex = playerCells.indexOf(smaller); if(pIndex !== -1) playerCells.splice(pIndex, 1); if(playerCells.length === 0) gameState = 'gameOver'; } else { const bIndex = bots.indexOf(smaller); if (bIndex !== -1) { bots.splice(bIndex, 1); bots.push(createBot()); } } } } } } for (let i = 0; i < playerCells.length; i++) { for (let j = i + 1; j < playerCells.length; j++) { const c1 = playerCells[i]; const c2 = playerCells[j]; const now = Date.now(); if (getDistance(c1.x, c1.y, c2.x, c2.y) < c1.radius && now > c1.mergeTime && now > c2.mergeTime) { c1.radius = Math.sqrt(c1.radius*c1.radius + c2.radius*c2.radius); playerCells.splice(j, 1); j--; } } } }
    </script>
</body>
</html>

